// DO NOT EDIT.
// code generated by goenums v0.4.3 at Aug  3 12:37:43.
//
// github.com/zarldev/goenums
//
// using the command:
// goenums lang.go

package onecall

import (
	"bytes"
	"database/sql/driver"
	"fmt"
	"iter"
	"math"

	"golang.org/x/exp/constraints"
)

// Lang is a type that represents a single enum value.
// It combines the core information about the enum constant and it's defined fields.
type Lang struct {
	lang
}

// langsContainer is the container for all enum values.
// It is private and should not be used directly use the public methods on the Lang type.
type langsContainer struct {
	UNKNOWNLANG        Lang
	ALBANIAN           Lang
	AFRIKAANS          Lang
	ARABIC             Lang
	AZERBAIJANI        Lang
	BASQUE             Lang
	BELARUSIAN         Lang
	BULGARIAN          Lang
	CATALAN            Lang
	CHINESESIMPLIFIED  Lang
	CHINESETRADITIONAL Lang
	CROATIAN           Lang
	CZECH              Lang
	DANISH             Lang
	DUTCH              Lang
	ENGLISH            Lang
	FINNISH            Lang
	FRENCH             Lang
	GALICIAN           Lang
	GERMAN             Lang
	GREEK              Lang
	HEBREW             Lang
	HINDI              Lang
	HUNGARIAN          Lang
	ICELANDIC          Lang
	INDONESIAN         Lang
	ITALIAN            Lang
	JAPANESE           Lang
	KOREAN             Lang
	KURMANJI           Lang
	LATVIAN            Lang
	LITHUANIAN         Lang
	MACEDONIAN         Lang
	NORWEGIAN          Lang
	PERSIAN            Lang
	POLISH             Lang
	PORTUGUESE         Lang
	PORTUGUESEBRAZIL   Lang
	ROMANIAN           Lang
	RUSSIAN            Lang
	SERBIAN            Lang
	SLOVAK             Lang
	SLOVENIAN          Lang
	SPANISH            Lang
	SWEDISH            Lang
	THAI               Lang
	TURKISH            Lang
	UKRAINIAN          Lang
	VIETNAMESE         Lang
	ZULU               Lang
}

// Langs is a main entry point using the Lang type.
// It it a container for all enum values and provides a convenient way to access all enum values and perform
// operations, with convenience methods for common use cases.
var Langs = langsContainer{
	UNKNOWNLANG: Lang{
		lang: unknownLang,
	},
	ALBANIAN: Lang{
		lang: Albanian,
	},
	AFRIKAANS: Lang{
		lang: Afrikaans,
	},
	ARABIC: Lang{
		lang: Arabic,
	},
	AZERBAIJANI: Lang{
		lang: Azerbaijani,
	},
	BASQUE: Lang{
		lang: Basque,
	},
	BELARUSIAN: Lang{
		lang: Belarusian,
	},
	BULGARIAN: Lang{
		lang: Bulgarian,
	},
	CATALAN: Lang{
		lang: Catalan,
	},
	CHINESESIMPLIFIED: Lang{
		lang: ChineseSimplified,
	},
	CHINESETRADITIONAL: Lang{
		lang: ChineseTraditional,
	},
	CROATIAN: Lang{
		lang: Croatian,
	},
	CZECH: Lang{
		lang: Czech,
	},
	DANISH: Lang{
		lang: Danish,
	},
	DUTCH: Lang{
		lang: Dutch,
	},
	ENGLISH: Lang{
		lang: English,
	},
	FINNISH: Lang{
		lang: Finnish,
	},
	FRENCH: Lang{
		lang: French,
	},
	GALICIAN: Lang{
		lang: Galician,
	},
	GERMAN: Lang{
		lang: German,
	},
	GREEK: Lang{
		lang: Greek,
	},
	HEBREW: Lang{
		lang: Hebrew,
	},
	HINDI: Lang{
		lang: Hindi,
	},
	HUNGARIAN: Lang{
		lang: Hungarian,
	},
	ICELANDIC: Lang{
		lang: Icelandic,
	},
	INDONESIAN: Lang{
		lang: Indonesian,
	},
	ITALIAN: Lang{
		lang: Italian,
	},
	JAPANESE: Lang{
		lang: Japanese,
	},
	KOREAN: Lang{
		lang: Korean,
	},
	KURMANJI: Lang{
		lang: Kurmanji,
	},
	LATVIAN: Lang{
		lang: Latvian,
	},
	LITHUANIAN: Lang{
		lang: Lithuanian,
	},
	MACEDONIAN: Lang{
		lang: Macedonian,
	},
	NORWEGIAN: Lang{
		lang: Norwegian,
	},
	PERSIAN: Lang{
		lang: Persian,
	},
	POLISH: Lang{
		lang: Polish,
	},
	PORTUGUESE: Lang{
		lang: Portuguese,
	},
	PORTUGUESEBRAZIL: Lang{
		lang: PortugueseBrazil,
	},
	ROMANIAN: Lang{
		lang: Romanian,
	},
	RUSSIAN: Lang{
		lang: Russian,
	},
	SERBIAN: Lang{
		lang: Serbian,
	},
	SLOVAK: Lang{
		lang: Slovak,
	},
	SLOVENIAN: Lang{
		lang: Slovenian,
	},
	SPANISH: Lang{
		lang: Spanish,
	},
	SWEDISH: Lang{
		lang: Swedish,
	},
	THAI: Lang{
		lang: Thai,
	},
	TURKISH: Lang{
		lang: Turkish,
	},
	UKRAINIAN: Lang{
		lang: Ukrainian,
	},
	VIETNAMESE: Lang{
		lang: Vietnamese,
	},
	ZULU: Lang{
		lang: Zulu,
	},
}

// invalidLang is an invalid sentinel value for Lang
var invalidLang = Lang{
	lang: -1,
}

// allSlice returns a slice of all enum values.
// This method is useful for iterating over all enum values in a loop.
func (l langsContainer) allSlice() []Lang {
	return []Lang{
		Langs.ALBANIAN,
		Langs.AFRIKAANS,
		Langs.ARABIC,
		Langs.AZERBAIJANI,
		Langs.BASQUE,
		Langs.BELARUSIAN,
		Langs.BULGARIAN,
		Langs.CATALAN,
		Langs.CHINESESIMPLIFIED,
		Langs.CHINESETRADITIONAL,
		Langs.CROATIAN,
		Langs.CZECH,
		Langs.DANISH,
		Langs.DUTCH,
		Langs.ENGLISH,
		Langs.FINNISH,
		Langs.FRENCH,
		Langs.GALICIAN,
		Langs.GERMAN,
		Langs.GREEK,
		Langs.HEBREW,
		Langs.HINDI,
		Langs.HUNGARIAN,
		Langs.ICELANDIC,
		Langs.INDONESIAN,
		Langs.ITALIAN,
		Langs.JAPANESE,
		Langs.KOREAN,
		Langs.KURMANJI,
		Langs.LATVIAN,
		Langs.LITHUANIAN,
		Langs.MACEDONIAN,
		Langs.NORWEGIAN,
		Langs.PERSIAN,
		Langs.POLISH,
		Langs.PORTUGUESE,
		Langs.PORTUGUESEBRAZIL,
		Langs.ROMANIAN,
		Langs.RUSSIAN,
		Langs.SERBIAN,
		Langs.SLOVAK,
		Langs.SLOVENIAN,
		Langs.SPANISH,
		Langs.SWEDISH,
		Langs.THAI,
		Langs.TURKISH,
		Langs.UKRAINIAN,
		Langs.VIETNAMESE,
		Langs.ZULU,
	}
}

// All returns an iterator over all enum values.
// This method is useful for iterating over all enum values in a loop.
func (l langsContainer) All() iter.Seq[Lang] {
	return func(yield func(Lang) bool) {
		for _, v := range l.allSlice() {
			if !yield(v) {
				return
			}
		}
	}
}

// ParseLang parses the input value into an enum value.
// It returns the parsed enum value or an error if the input is invalid.
// It is a convenience function that can be used to parse enum values from
// various input types, such as strings, byte slices, or other enum types.
func ParseLang(input any) (Lang, error) {
	switch v := input.(type) {
	case Lang:
		return v, nil
	case string:
		if result := stringToLang(v); result != nil {
			return *result, nil
		}
	case fmt.Stringer:
		if result := stringToLang(v.String()); result != nil {
			return *result, nil
		}
	case []byte:
		if result := stringToLang(string(v)); result != nil {
			return *result, nil
		}
	case int:
		if result := numberToLang(v); result != nil {
			return *result, nil
		}
	case int8:
		if result := numberToLang(v); result != nil {
			return *result, nil
		}
	case int16:
		if result := numberToLang(v); result != nil {
			return *result, nil
		}
	case int32:
		if result := numberToLang(v); result != nil {
			return *result, nil
		}
	case int64:
		if result := numberToLang(v); result != nil {
			return *result, nil
		}
	case uint:
		if result := numberToLang(v); result != nil {
			return *result, nil
		}
	case uint8:
		if result := numberToLang(v); result != nil {
			return *result, nil
		}
	case uint16:
		if result := numberToLang(v); result != nil {
			return *result, nil
		}
	case uint32:
		if result := numberToLang(v); result != nil {
			return *result, nil
		}
	case uint64:
		if result := numberToLang(v); result != nil {
			return *result, nil
		}
	case float32:
		if result := numberToLang(v); result != nil {
			return *result, nil
		}
	case float64:
		if result := numberToLang(v); result != nil {
			return *result, nil
		}
	default:
		return invalidLang, fmt.Errorf("invalid type %T", input)
	}
	return invalidLang, nil
}

// langsNameMap is a map of enum values to their Lang representation
// It is used to convert string representations of enum values into their Lang representation.
var langsNameMap = map[string]Lang{
	"unknownLang": Langs.UNKNOWNLANG,
	"sq":          Langs.ALBANIAN,
	"af":          Langs.AFRIKAANS,
	"ar":          Langs.ARABIC,
	"az":          Langs.AZERBAIJANI,
	"eu":          Langs.BASQUE,
	"be":          Langs.BELARUSIAN,
	"bg":          Langs.BULGARIAN,
	"ca":          Langs.CATALAN,
	"zh_cn":       Langs.CHINESESIMPLIFIED,
	"zh_tw":       Langs.CHINESETRADITIONAL,
	"hr":          Langs.CROATIAN,
	"cz":          Langs.CZECH,
	"da":          Langs.DANISH,
	"nl":          Langs.DUTCH,
	"en":          Langs.ENGLISH,
	"fi":          Langs.FINNISH,
	"fr":          Langs.FRENCH,
	"gl":          Langs.GALICIAN,
	"de":          Langs.GERMAN,
	"el":          Langs.GREEK,
	"he":          Langs.HEBREW,
	"hi":          Langs.HINDI,
	"hu":          Langs.HUNGARIAN,
	"is":          Langs.ICELANDIC,
	"id":          Langs.INDONESIAN,
	"it":          Langs.ITALIAN,
	"ja":          Langs.JAPANESE,
	"kr":          Langs.KOREAN,
	"ku":          Langs.KURMANJI,
	"la":          Langs.LATVIAN,
	"lt":          Langs.LITHUANIAN,
	"mk":          Langs.MACEDONIAN,
	"no":          Langs.NORWEGIAN,
	"fa":          Langs.PERSIAN,
	"pl":          Langs.POLISH,
	"pt":          Langs.PORTUGUESE,
	"pt_br":       Langs.PORTUGUESEBRAZIL,
	"ro":          Langs.ROMANIAN,
	"ru":          Langs.RUSSIAN,
	"sr":          Langs.SERBIAN,
	"sk":          Langs.SLOVAK,
	"sl":          Langs.SLOVENIAN,
	"sp":          Langs.SPANISH,
	"sv":          Langs.SWEDISH,
	"th":          Langs.THAI,
	"tr":          Langs.TURKISH,
	"ua":          Langs.UKRAINIAN,
	"vi":          Langs.VIETNAMESE,
	"zu":          Langs.ZULU,
}

// stringToLang converts a string representation of an enum value into its Lang representation
// It returns a pointer to the Lang representation of the enum value if the string is valid
// Otherwise, it returns nil
func stringToLang(s string) *Lang {
	if t, ok := langsNameMap[s]; ok {
		return &t
	}
	return nil
}

// numberToLang converts a numeric value to a Lang
// It returns a pointer to the Lang representation of the enum value if the numeric value is valid
// Otherwise, it returns nil
func numberToLang[T constraints.Integer | constraints.Float](num T) *Lang {
	f := float64(num)
	if math.Floor(f) != f {
		return nil
	}
	i := int(f)
	if i <= 0 || i > len(Langs.allSlice()) {
		return nil
	}
	result := Langs.allSlice()[i-1]
	if !result.IsValid() {
		return nil
	}
	return &result
}

// ExhaustiveLangs iterates over all enum values and calls the provided function for each value.
// This function is useful for performing operations on all valid enum values in a loop.
func ExhaustiveLangs(f func(Lang)) {
	for _, p := range Langs.allSlice() {
		f(p)
	}
}

// validLangs is a map of enum values to their validity
var validLangs = map[Lang]bool{
	Langs.UNKNOWNLANG:        false,
	Langs.ALBANIAN:           true,
	Langs.AFRIKAANS:          true,
	Langs.ARABIC:             true,
	Langs.AZERBAIJANI:        true,
	Langs.BASQUE:             true,
	Langs.BELARUSIAN:         true,
	Langs.BULGARIAN:          true,
	Langs.CATALAN:            true,
	Langs.CHINESESIMPLIFIED:  true,
	Langs.CHINESETRADITIONAL: true,
	Langs.CROATIAN:           true,
	Langs.CZECH:              true,
	Langs.DANISH:             true,
	Langs.DUTCH:              true,
	Langs.ENGLISH:            true,
	Langs.FINNISH:            true,
	Langs.FRENCH:             true,
	Langs.GALICIAN:           true,
	Langs.GERMAN:             true,
	Langs.GREEK:              true,
	Langs.HEBREW:             true,
	Langs.HINDI:              true,
	Langs.HUNGARIAN:          true,
	Langs.ICELANDIC:          true,
	Langs.INDONESIAN:         true,
	Langs.ITALIAN:            true,
	Langs.JAPANESE:           true,
	Langs.KOREAN:             true,
	Langs.KURMANJI:           true,
	Langs.LATVIAN:            true,
	Langs.LITHUANIAN:         true,
	Langs.MACEDONIAN:         true,
	Langs.NORWEGIAN:          true,
	Langs.PERSIAN:            true,
	Langs.POLISH:             true,
	Langs.PORTUGUESE:         true,
	Langs.PORTUGUESEBRAZIL:   true,
	Langs.ROMANIAN:           true,
	Langs.RUSSIAN:            true,
	Langs.SERBIAN:            true,
	Langs.SLOVAK:             true,
	Langs.SLOVENIAN:          true,
	Langs.SPANISH:            true,
	Langs.SWEDISH:            true,
	Langs.THAI:               true,
	Langs.TURKISH:            true,
	Langs.UKRAINIAN:          true,
	Langs.VIETNAMESE:         true,
	Langs.ZULU:               true,
}

// IsValid checks whether the Langs value is valid.
// A valid value is one that is defined in the original enum and not marked as invalid.
func (l Lang) IsValid() bool {
	return validLangs[l]
}

// MarshalJSON implements the json.Marshaler interface for Lang.
// It returns the JSON representation of the enum value as a byte slice.
func (l Lang) MarshalJSON() ([]byte, error) {
	return []byte("\"" + l.String() + "\""), nil
}

// UnmarshalJSON implements the json.Unmarshaler interface for Lang.
// It parses the JSON representation of the enum value from the byte slice.
// It returns an error if the input is not a valid JSON representation.
func (l *Lang) UnmarshalJSON(b []byte) error {
	b = bytes.Trim(bytes.Trim(b, "\""), "\"")
	newl, err := ParseLang(b)
	if err != nil {
		return err
	}
	*l = newl
	return nil
}

// MarshalText implements the encoding.TextMarshaler interface for Lang.
// It returns the string representation of the enum value as a byte slice
func (l Lang) MarshalText() ([]byte, error) {
	return []byte("\"" + l.String() + "\""), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for Lang.
// It parses the string representation of the enum value from the byte slice.
// It returns an error if the byte slice does not contain a valid enum value.
func (l *Lang) UnmarshalText(b []byte) error {
	newl, err := ParseLang(b)
	if err != nil {
		return err
	}
	*l = newl
	return nil
}

// Scan implements the database/sql.Scanner interface for Lang.
// It parses the string representation of the enum value from the database row.
// It returns an error if the row does not contain a valid enum value.
func (l *Lang) Scan(value any) error {
	newl, err := ParseLang(value)
	if err != nil {
		return err
	}
	*l = newl
	return nil
}

// Value implements the database/sql/driver.Valuer interface for Lang.
// It returns the string representation of the enum value.
func (l Lang) Value() (driver.Value, error) {
	return l.String(), nil
}

// MarshalBinary implements the encoding.BinaryMarshaler interface for Lang.
// It returns the binary representation of the enum value as a byte slice.
func (l Lang) MarshalBinary() ([]byte, error) {
	return []byte("\"" + l.String() + "\""), nil
}

// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface for Lang.
// It parses the binary representation of the enum value from the byte slice.
// It returns an error if the byte slice does not contain a valid enum value.
func (l *Lang) UnmarshalBinary(b []byte) error {
	newl, err := ParseLang(b)
	if err != nil {
		return err
	}
	*l = newl
	return nil
}

// MarshalYAML implements the yaml.Marshaler interface for Lang.
// It returns the string representation of the enum value.
func (l Lang) MarshalYAML() ([]byte, error) {
	return []byte(l.String()), nil
}

// UnmarshalYAML implements the yaml.Unmarshaler interface for Planet.
// It parses the byte slice representation of the enum value and returns an error
// if the YAML byte slice does not contain a valid enum value.
func (l *Lang) UnmarshalYAML(b []byte) error {
	newl, err := ParseLang(b)
	if err != nil {
		return err
	}
	*l = newl
	return nil
}

// langNames is a constant string slice containing all enum values cononical absolute names
const langNames = "unknownLangsqafarazeubebgcazh_cnzh_twhrczdanlenfifrgldeelhehihuisiditjakrkulaltmknofaplptpt_brrorusrskslspsvthtruavizu"

// langNamesMap is a map of enum values to their canonical absolute
// name positions within the langNames string slice
var langNamesMap = map[Lang]string{
	Langs.UNKNOWNLANG:        langNames[0:11],
	Langs.ALBANIAN:           langNames[11:13],
	Langs.AFRIKAANS:          langNames[13:15],
	Langs.ARABIC:             langNames[15:17],
	Langs.AZERBAIJANI:        langNames[17:19],
	Langs.BASQUE:             langNames[19:21],
	Langs.BELARUSIAN:         langNames[21:23],
	Langs.BULGARIAN:          langNames[23:25],
	Langs.CATALAN:            langNames[25:27],
	Langs.CHINESESIMPLIFIED:  langNames[27:32],
	Langs.CHINESETRADITIONAL: langNames[32:37],
	Langs.CROATIAN:           langNames[37:39],
	Langs.CZECH:              langNames[39:41],
	Langs.DANISH:             langNames[41:43],
	Langs.DUTCH:              langNames[43:45],
	Langs.ENGLISH:            langNames[45:47],
	Langs.FINNISH:            langNames[47:49],
	Langs.FRENCH:             langNames[49:51],
	Langs.GALICIAN:           langNames[51:53],
	Langs.GERMAN:             langNames[53:55],
	Langs.GREEK:              langNames[55:57],
	Langs.HEBREW:             langNames[57:59],
	Langs.HINDI:              langNames[59:61],
	Langs.HUNGARIAN:          langNames[61:63],
	Langs.ICELANDIC:          langNames[63:65],
	Langs.INDONESIAN:         langNames[65:67],
	Langs.ITALIAN:            langNames[67:69],
	Langs.JAPANESE:           langNames[69:71],
	Langs.KOREAN:             langNames[71:73],
	Langs.KURMANJI:           langNames[73:75],
	Langs.LATVIAN:            langNames[75:77],
	Langs.LITHUANIAN:         langNames[77:79],
	Langs.MACEDONIAN:         langNames[79:81],
	Langs.NORWEGIAN:          langNames[81:83],
	Langs.PERSIAN:            langNames[83:85],
	Langs.POLISH:             langNames[85:87],
	Langs.PORTUGUESE:         langNames[87:89],
	Langs.PORTUGUESEBRAZIL:   langNames[89:94],
	Langs.ROMANIAN:           langNames[94:96],
	Langs.RUSSIAN:            langNames[96:98],
	Langs.SERBIAN:            langNames[98:100],
	Langs.SLOVAK:             langNames[100:102],
	Langs.SLOVENIAN:          langNames[102:104],
	Langs.SPANISH:            langNames[104:106],
	Langs.SWEDISH:            langNames[106:108],
	Langs.THAI:               langNames[108:110],
	Langs.TURKISH:            langNames[110:112],
	Langs.UKRAINIAN:          langNames[112:114],
	Langs.VIETNAMESE:         langNames[114:116],
	Langs.ZULU:               langNames[116:118],
}

// String implements the Stringer interface.
// It returns the canonical absolute name of the enum value.
func (l Lang) String() string {
	if str, ok := langNamesMap[l]; ok {
		return str
	}
	return fmt.Sprintf("lang(%d)", l.lang)
}

// Compile-time check that all enum values are valid.
// This function is used to ensure that all enum values are defined and valid.
// It is called by the compiler to verify that the enum values are valid.
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the goenums command to generate them again.
	// Does not identify newly added constant values unless order changes
	var x [50]struct{}
	_ = x[unknownLang]
	_ = x[Albanian-1]
	_ = x[Afrikaans-2]
	_ = x[Arabic-3]
	_ = x[Azerbaijani-4]
	_ = x[Basque-5]
	_ = x[Belarusian-6]
	_ = x[Bulgarian-7]
	_ = x[Catalan-8]
	_ = x[ChineseSimplified-9]
	_ = x[ChineseTraditional-10]
	_ = x[Croatian-11]
	_ = x[Czech-12]
	_ = x[Danish-13]
	_ = x[Dutch-14]
	_ = x[English-15]
	_ = x[Finnish-16]
	_ = x[French-17]
	_ = x[Galician-18]
	_ = x[German-19]
	_ = x[Greek-20]
	_ = x[Hebrew-21]
	_ = x[Hindi-22]
	_ = x[Hungarian-23]
	_ = x[Icelandic-24]
	_ = x[Indonesian-25]
	_ = x[Italian-26]
	_ = x[Japanese-27]
	_ = x[Korean-28]
	_ = x[Kurmanji-29]
	_ = x[Latvian-30]
	_ = x[Lithuanian-31]
	_ = x[Macedonian-32]
	_ = x[Norwegian-33]
	_ = x[Persian-34]
	_ = x[Polish-35]
	_ = x[Portuguese-36]
	_ = x[PortugueseBrazil-37]
	_ = x[Romanian-38]
	_ = x[Russian-39]
	_ = x[Serbian-40]
	_ = x[Slovak-41]
	_ = x[Slovenian-42]
	_ = x[Spanish-43]
	_ = x[Swedish-44]
	_ = x[Thai-45]
	_ = x[Turkish-46]
	_ = x[Ukrainian-47]
	_ = x[Vietnamese-48]
	_ = x[Zulu-49]
}
